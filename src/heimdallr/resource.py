import os
import subprocess
from abc import ABC, abstractmethod
from csv import DictWriter
from datetime import datetime
from typing import Iterable, Dict, List, Tuple, Set

from .utils import to_local_str


class Resource(ABC):
    """Represents an abstract system resource that should be monitored.

    All resources need to define the output file where the CSV will be saved.

    """

    def __init__(self, output_file):
        self._output_file = output_file

    @abstractmethod
    def fetch_data(self, config) -> Iterable[Dict[str, object]]:
        """Fetch the data for the resource.

        This method should return an iterable that yields dict items containing the data to save to the CSV file.
        Each dict will be written in a separate row, in the order in which they are yielded.

        """
        raise NotImplementedError

    @property
    @abstractmethod
    def column_names(self) -> List[str]:
        """Return the list of column names."""

    def monitor(self, config, header=True):
        """Monitors the resource.

        This method should NOT be overridden by subclasses. All the logic for fetching, parsing and combining data
        should be done inside the `fetch_data` method.

        """
        missing_options = self.required_options() - config.keys()
        if missing_options:
            raise ValueError('You must provide a value for options: {}'.format(', '.join(missing_options)))
        with open(self._output_file, 'a') as out_file:
            writer = DictWriter(out_file, self.column_names)
            if header:
                writer.writeheader()
            for data_row in self.fetch_data(config):
                writer.writerow(data_row)

    @classmethod
    def required_options(cls) -> Set[str]:
        """Returns a set of options that must be present in the configuration for the resource.

        By default no option is required.

        """
        return set()


class NullResource(Resource):
    """A null resource. This is use as a placeholder when no resource is given."""

    def __init__(self):
        super().__init__(None)

    def fetch_data(self, config) -> Iterable[Dict[str, object]]:
        """Returns an empty iterable."""
        return []

    @property
    def column_names(self) -> List[str]:
        """No columns are defined"""
        return []

    def monitor(self, config, header=True):
        """Does nothing."""
        return


class SimpleCommandResource(Resource):
    """Base class for resources that are defined by running a single command and parsing its result with a regex.

    Most resources fall into this simple category.

    Subclasses of this class must define at least two methods `make_cmdline` and `make_regex`.
    The `make_cmdline` method returns a list of strings that is used as a command line
    while `make_regex` should return a regex object that can be used to parse the output of the
    command specified.

    The regex can be used in two ways:
     - to parse the whole output using the `fullmatch` method (the default).
     - to parse "rows of data" from the output using the `finditer` method.
    To specify the latter behaviour you have to set `table_output=True`, indicating that the output of your
    command can be treated as a table and the regex is treated as a regex matching one line from that table.

    In both cases the dict object generated by `fetch_data` will be the result of `match.groupdict()` with
    the addition of the special column `datetime` which will always contain the current time.

    """

    def __init__(self, output_file, table_output=False):
        super().__init__(output_file)
        self._column_names = None
        self._table_output = table_output

    @property
    def column_names(self):
        if self._column_names is None:
            regex = self.make_regex({})
            self._column_names = ['datetime'] + sorted(regex.groupindex.keys(), key=regex.groupindex.get)
        return self._column_names

    def fetch_data(self, config):
        """Fetches the data from the command returned by `make_cmdline`.

        The `config` argument may contain the `backup_bad_output_dir` parameter.
        If specified, it should be the path to a directory in which we can
        save files containing the output of the commands run. These outputs will be created whenever parsing
        using the regex fails.
        This behaviour is useful in two instances:
         - to debug the regex during development
         - to avoid losing data in unexpected circumstances in production
        By default no output is saved.

        """
        cmdline = self.make_cmdline(config)
        result = subprocess.run(cmdline, stdout=subprocess.PIPE)
        yield from self._generic_parse(result.stdout.decode('utf-8'), config, cmdline[0])

    @staticmethod
    def _backup_output(command_name, bad_output_dir, output):
        if bad_output_dir:
            path = os.path.join(bad_output_dir, 'bad_{}_{}.txt'.format(command_name, to_local_str(datetime.now())))
            with open(path, 'wb') as bad_file:
                bad_file.write(output.encode('utf-8') or b'')

    def _generic_parse(self, output, config, command_name='command'):
        cleaned_output = self.clean_output(output, config)
        regex = self.make_regex(config)
        if self._table_output:
            info = {'datetime': to_local_str(datetime.now()), 'values': []}
            for match in regex.finditer(cleaned_output):
                res = match.groupdict()
                info['values'].append(res)
            if not info['values']:
                self._backup_output(command_name, config.get('backup_bad_output_dir'), output)
        else:
            match = regex.fullmatch(cleaned_output)
            if match:
                info = match.groupdict()
            else:
                info = dict.fromkeys(self.column_names, 'N/A')
                self._backup_output(command_name, config.get('backup_bad_output_dir'), output)
            info['datetime'] = to_local_str(datetime.now())
        yield from self.clean_data(info, config)

    def clean_output(self, output, config):
        """This method should return clean `output` and return a string that will be matched
        with the regex.

        """
        return output

    def clean_data(self, info, config):
        """This method will be called with the result of the parsing of the output via the regex
        and should return an iterable of dicts ready to be written to the CSV file.

        """
        yield info

    @abstractmethod
    def make_cmdline(self, config):
        """Return the command line to run to fetch the data for this configuration."""

    @abstractmethod
    def make_regex(self, config):
        """Return the regex to parse the output for this configuration."""


class MultiCommandResource(Resource):
    """Base class for resources that are defined by running multiple commands and parsing their result with a regex.

    Subclasses of this class must define at least four methods:
     - `column_names`
     - `make_cmdlines`
     - `make_regexes`
     - `combine_results`

    The `column_names` property should return the header file for the CSV.

    The `make_cmdlines` method returns an iterable of list of strings, that are used as command lines.

    The `make_regexes` should return an iterable of pairs whose first element is a regex object, that can be used to
    parse the output of the corresponding command, and a boolean indicating wheter or not the output is "tabled".

    The `combine_results` should take the list of parsed results from the various commands and generate an iterable
    of dicts containing the data to be written to the logfile.

    """

    def __init__(self, output_file):
        super().__init__(output_file)
        self._column_names = None

    def fetch_data(self, config):
        """Fetches the data from the command returned by `make_cmdline`.

        The `config` argument may contain the `backup_bad_output_dir` parameter.
        If specified, it should be the path to a directory in which we can
        save files containing the output of the commands run. These outputs will be created whenever parsing
        using the regex fails.
        This behaviour is useful in two instances:
         - to debug the regex during development
         - to avoid losing data in unexpected circumstances in production
        By default no output is saved.

        """
        results = []
        for cmdline, (regex, table_output) in zip(self.make_cmdlines(config), self.make_regexes(config)):
            result = subprocess.run(cmdline, stdout=subprocess.PIPE).stdout.decode('utf-8')
            results.append(self._generic_parse(result, config, regex, table_output, command_name=cmdline[0]))
        yield from self.combine_results(results, config)

    @staticmethod
    def _backup_output(command_name, bad_output_dir, output):
        if bad_output_dir:
            path = os.path.join(bad_output_dir, 'bad_{}_{}.txt'.format(command_name, to_local_str(datetime.now())))
            with open(path, 'wb') as bad_file:
                bad_file.write(output.encode('utf-8') or b'')

    def _generic_parse(self, output, config, regex, table_output, command_name='command'):
        cleaned_output = self.clean_output(output, command_name, config)
        if table_output:
            info = {'datetime': to_local_str(datetime.now()), 'values': []}
            for match in regex.finditer(cleaned_output):
                res = match.groupdict()
                info['values'].append(res)
            if not info['values']:
                self._backup_output(command_name, config.get('backup_bad_output_dir'), output)
        else:
            match = regex.fullmatch(cleaned_output)
            if match:
                info = match.groupdict()
            else:
                info = dict.fromkeys(self.column_names, 'N/A')
                self._backup_output(command_name, config.get('backup_bad_output_dir'), output)
            info['datetime'] = to_local_str(datetime.now())
        return info

    def clean_output(self, output, command_name, config):
        """This method should return clean `output` and return a string that will be matched
        with the regex.

        """
        return output

    @abstractmethod
    def make_cmdlines(self, config):
        """Return the command lines to run to fetch the data for this configuration.

        Each element of the returned iterable shall be a pair `(cmdline, table_output)` where
        `cmdline` is a list of strings that can be used as a command line while `table_output` is a
        boolean. If `table_output` is `False` the output of `cmdline` will be parsed using the `fullmatch` method,
        while if `table_outut` is `True` the `finditer` method will be used instead.

        """

    @abstractmethod
    def make_regexes(self, config):
        """Return the regex to parse the output for this configuration."""

    @abstractmethod
    def combine_results(self, results, config):
        """Combine the parsed results of the different commands."""